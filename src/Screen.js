/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useCallback, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei/useGLTF'
import { useSpring, a } from '@react-spring/three'
import { useFrame } from 'react-three-fiber'
import lerp from 'lerp'
import niceColorPalette from 'nice-color-palettes/1000'
import { useWheel } from './store'

export default function Screen({ wheelIndex, opacity, ...props }) {
  const ref = useRef()
  const { nodes } = useGLTF('/Screen.gltf')
  const scale = opacity === 1 ? 1.4 : 1
  const setWheelIndex = useWheel((s) => s.setWheelIndex)
  const toggle = useWheel((s) => s.toggleWheel)
  const wheelOpen = useWheel((s) => s.wheelOpen)
  const setPalette = useWheel((s) => s.setPalette)
  const [localOpen, setLocalOpen] = useState(wheelOpen)
  const color = niceColorPalette[wheelIndex]

  const springOpacityRef = useRef()
  const { springOpacity } = useSpring({
    ref: springOpacityRef,
    springOpacity: opacity === 1 ? 1 : 0
  })

  useEffect(() => {
    if (wheelOpen) {
      if (localOpen) {
        springOpacityRef.current.start({
          springOpacity: opacity
        })
      } else {
        springOpacityRef.current.start({
          springOpacity: opacity,
          delay: 1000,
          onRest: () => setLocalOpen(true)
        })
      }
    } else {
      springOpacityRef.current.start({
        springOpacity: opacity === 1 ? 1 : 0,
        onRest: () => setLocalOpen(false)
      })
    }
    if (opacity === 1) {
      setPalette(color)
    }
  }, [localOpen, setLocalOpen, wheelOpen, opacity, setPalette, color])

  useFrame(() => {
    const newScale = lerp(ref.current.scale.x, scale, 0.1)
    ref.current.scale.set(newScale, newScale, newScale)
  })

  const handleClick = useCallback(
    (e) => {
      e.stopPropagation()
      if (wheelIndex) {
        if (wheelOpen) {
          setWheelIndex(wheelIndex)
          toggle()
        } else {
          if (opacity === 1) {
            toggle()
          }
        }
      }
    },
    [setWheelIndex, wheelOpen, opacity, wheelIndex, toggle]
  )

  return (
    <group visible={opacity > 0.01} onClick={handleClick} ref={ref} {...props}>
      <group position={[1, -0.51, 1]} scale={[1.27, 1.27, 1.27]} dispose={null} rotation={[0, Math.PI / 2, 0]}>
        <mesh geometry={nodes.Slice001.geometry} position={[0.97, 0.39, -0.91]} renderOrder={0} scale={[15, 1, 1]}>
          <a.meshPhysicalMaterial color="black" metalness={1} clearcoat={1} roughness={1} transparent opacity={springOpacity} />
        </mesh>
        <a.mesh castShadow geometry={nodes.Slice.geometry} renderOrder={1}>
          <a.meshPhysicalMaterial
            transmission={1}
            metalness={0}
            clearcoat={1}
            roughness={0}
            transparent
            color="#222"
            opacity={springOpacity}
          />
        </a.mesh>
      </group>
      {color
        ? color.map((c, i) => (
            <mesh key={`0${i}`} position-x={(i - 2.5) / 3.8} position-z={-0.24} renderOrder={0}>
              <boxBufferGeometry args={[0.265, 0.8, 0.02]} />
              <a.meshStandardMaterial color={c} transparent opacity={springOpacity} metalness={0} roughness={1} />
            </mesh>
          ))
        : null}
    </group>
  )
}

useGLTF.preload('/Screen.gltf')
